//
// HomeLisp Вер. 1.8.33 (Файфель Б.Л.)
//
(SEXPR fib_r ( LAMBDA (x)(COND ((EQ x 1) 1)((EQ x 2) 1)(T (PLUS (fib_r (DIFFERENCE x 1))(fib_r (DIFFERENCE x 2)))))) )
(SEXPR fib_n ( LAMBDA (x)(COND ((EQ x 1) 1)((EQ x 2) 1)(T (PROG (a1 a2 r c)(SETQ a1 1)(SETQ a2 1)(SETQ c x)(SETQ c (DIFFERENCE c 2)) L (SETQ r (PLUS a1 a2))(SETQ a1 a2)(SETQ a2 r)(SETQ c (DIFFERENCE c 1))(COND ((EQ c 0)(RETURN r))(T (GO L))))))) )
(SEXPR fact ( LAMBDA (x)(COND ((EQ x 1) 1)(T (TIMES x (fact (DIFFERENCE x 1)))))) )
(SEXPR copy ( LAMBDA (x)(COND ((ATOM x) x)(T (CONS (copy (CAR x))(copy (CDR x)))))) )
(SEXPR append ( LAMBDA (x y)(COND ((NULL x) y)(T (CONS (CAR x)(append (CDR x) y))))) )
(SEXPR equal ( LAMBDA (x y)(COND ((ATOM x)(EQ x y))((ATOM y) NIL)((equal (CAR x)(CAR y))(equal (CDR x)(CDR y)))(T NIL))) )
(SEXPR member ( LAMBDA (x y)(COND ((NULL y) NIL)((equal x (CAR y)) T)(T (member x (CDR y))))) )
(SEXPR memb ( LAMBDA (x y)(PROG NIL L (COND ((NULL y)(RETURN NIL))((EQ x (CAR y))(RETURN T)))(SETQ y (CDR y))(GO L))) )
(SEXPR rev1 ( LAMBDA (u v)(COND ((NULL u) v)(T (rev1 (CDR u)(CONS (rev (CAR u)) v))))) )
(SEXPR rev ( LAMBDA (x)(COND ((ATOM x) x)(T (rev1 (PRINT x) NIL)))) )
(SEXPR remove ( LAMBDA (x L)(COND ((NULL L) NIL)((equal x (CAR L))(remove x (CDR L)))(T (CONS (CAR L)(remove x (CDR L)))))) )
(SEXPR removef ( LAMBDA (x y)(COND ((NULL y) NIL)((equal x (CAR y))(CDR y))(T (CONS (CAR y)(removef x (CDR y)))))) )
(SEXPR last ( LAMBDA (x)(COND ((NULL x) NIL)((NULL (CDR x))(CAR x))(T (last (CDR x))))) )
(SEXPR length ( LAMBDA (x)(COND ((ATOM x) 0)(T (PLUS 1 (length (CDR x)))))) )
(SEXPR addifnone ( LAMBDA (x L)(COND ((member x L) L)(T (CONS x L)))) )
(SEXPR collect ( LAMBDA (L)(COND ((NULL L) NIL)(T (CONS (CAR L)(collect (COND ((member (CAR L)(CDR L))(CONS (CAR L)(removef (CAR L)(CDR L))))(T (CDR L)))))))) )
(SEXPR reverse ( LAMBDA (x)(PROG (u) a (COND ((NULL x)(RETURN u)))(SETQ u (CONS (CAR x) u))(SETQ x (CDR x))(GO a))) )
(SEXPR flatten ( LAMBDA (x)(COND ((NULL x) NIL)((ATOM x)(LIST x))(T (append (flatten (CAR x))(flatten (CDR x)))))) )
(SEXPR attach ( LAMBDA (x y)(RPLACA (RPLACD y (CONS (CAR y)(CDR y))) x)) )
(SEXPR dreverse ( LAMBDA (x)(PROG (u v) a (COND ((NULL x)(RETURN u)))(SETQ v x)(SETQ x (CDR x))(SETQ u (RPLACD v u))(GO a))) )
(SEXPR nconc ( LAMBDA (x y)(COND ((NULL x) y)(T (RPLACD x (nconc (CDR x) y))))) )
(SEXPR tconc ( LAMBDA (x q)(COND ((NULL q)(CONS (SETQ q (CONS x NIL)) q))(T (RPLACD q (CDR (RPLACD (CDR q)(CONS x NIL))))))) )
(SEXPR efface ( LAMBDA (x y)(COND ((NULL y) NIL)((equal x (CAR y))(CDR y))(T (RPLACD y (efface x (CDR y)))))) )
(SEXPR dremove ( LAMBDA (x y)(COND ((NULL y) NIL)((equal x (CAR y))(dremove x (CDR y)))(T (RPLACD y (dremove x (CDR y)))))) )
(SEXPR lcyclep ( LAMBDA (x)(AND (NOT (ATOM x))(NOT (ATOM (CDR x)))(lcycle1 (CDR x)(CDDR x)))) )
(SEXPR lcycle1 ( LAMBDA (x y)(OR (EQ x y)(AND (NOT (ATOM y))(NOT (ATOM (CDR y)))(lcycle1 (CDR x)(CDDR y))))) )
(SEXPR cyclep ( LAMBDA (x)(NOT (cycle1 x NIL (QUOTE (T))))) )
(SEXPR cycle1 ( LAMBDA (x u v)(COND ((ATOM x) v)((memb x u) NIL)((memb x v) v)((NULL (SETQ v (cycle1 (CAR x)(SETQ u (CONS x u)) v))) NIL)((NULL (SETQ v (cycle1 (CDR x) u v))) NIL)(T (CONS x v)))) )
(SEXPR forall ( LAMBDA (L p)(COND ((NULL L) T)((p (CAR L))(forall (CDR L) p))(T NIL))) )
(SEXPR forsome ( LAMBDA (L p)(COND ((NULL L) NIL)((p (CAR L)) T)(T (forsome (CDR L) p)))) )
(SEXPR forodd ( LAMBDA (L p)(COND ((NULL L) NIL)((p (CAR L))(NOT (forodd (CDR L) p)))(T (forodd (CDR L) p)))) )
(SEXPR atomlist ( LAMBDA (x)(COND ((NULL x) T)((ATOM x) NIL)((ATOM (CAR x))(atomlist (CDR x)))(T NIL))) )
(SEXPR listp ( LAMBDA (x)(COND ((NULL x) T)((ATOM x) NIL)((OR (ATOM (CAR x))(listp (CAR x)))(listp (CDR x)))(T NIL))) )
(SEXPR order ( LAMBDA (x y L)(COND ((NULL L) NIL)((equal x (CAR L)) T)((equal y (CAR L)) NIL)(T (order x y (CDR L))))) )
(SEXPR order1 ( LAMBDA (x y L)(COND ((NULL L)(QUOTE orderundef))((equal x (CAR L)) T)((equal y (CAR L)) NIL)(T (order1 x y (CDR L))))) )
(SEXPR lexorder ( LAMBDA (x y L)(COND ((NULL x) T)((NULL y) NIL)((equal (CAR x)(CAR y))(lexorder (CDR x)(CDR y) L))(T (order1 (CAR x)(CAR y) L)))) )
(SEXPR lexorder1 ( LAMBDA (x y L)(COND ((NULL x) T)((NULL y) NIL)((NULL L)(QUOTE lexorderundef))((equal (CAR x)(CAR y))(lexorder1 (CDR x)(CDR y)(CDR L)))(T (order1 (CAR x)(CAR y)(CAR L))))) )
(SEXPR first ( LAMBDA (x y)(COND ((NULL y)(CAR x))((member (CAR y) x)(CAR y))(T (first x (CDR y))))) )
(SEXPR rank ( LAMBDA (x y)(COND ((NULL x) NIL)(T (CONS (first x y)(rank (removef (first x y) x) y))))) )
(SEXPR possessing ( LAMBDA (p L)(PROG (u) a (COND ((NULL L)(RETURN (reverse u)))((p (CAR L))(SETQ u (CONS (CAR L) u))))(SETQ L (CDR L))(GO a))) )
(SEXPR suchthat ( LAMBDA (p L)(COND ((NULL L) NIL)((p (CAR L))(CAR L))(T (suchthat p (CDR L))))) )
(SEXPR suchthat1 ( LAMBDA (p L x y)(COND ((NULL L) x)((p (CAR L)) y)(T (suchthat1 p (CDR L) x y)))) )
(SEXPR suchthat2 ( LAMBDA (p L f)(COND ((NULL L) NIL)((p (CAR L))(f L))(T (suchthat2 p (CDR L) f)))) )
(SEXPR setof ( LAMBDA (x)(COND ((NULL x) NIL)((member (CAR x)(CDR x))(setof (CDR x)))(T (CONS (CAR x)(setof (CDR x)))))) )
(SEXPR makeset ( LAMBDA (x)(PROG (y) a (COND ((NULL x)(RETURN y))((NULL (member (CAR x) y))(SETQ y (CONS (CAR x) y))))(SETQ x (CDR x))(GO a))) )
(SEXPR diflist ( LAMBDA (x y)(COND ((NULL y) x)(T (diflist (remove (CAR y) x)(CDR y))))) )
(SEXPR subset ( LAMBDA (x y)(NULL (diflist x y))) )
(SEXPR union0 ( LAMBDA (x y)(COND ((NULL x) y)((member (CAR x) y)(union (CDR x) y))(T (CONS (CAR x)(union (CDR x) y))))) )
(SEXPR union ( LAMBDA (x y)(PROG NIL (SETQ y (makeset y)) a (COND ((NULL x)(RETURN y))((NOT (member (CAR x) y))(SETQ y (CONS (CAR x) y))))(SETQ x (CDR x))(GO a))) )
(SEXPR lunion ( LAMBDA (x)(COND ((NULL x) NIL)(T (union (CAR x)(lunion (CDR x)))))) )
(SEXPR intersection ( LAMBDA (x y)(COND ((NULL x) NIL)((member (CAR x) y)(CONS (CAR x)(intersection (CDR x) y)))(T (intersection (CDR x) y)))) )
(SEXPR equalset ( LAMBDA (x y)(AND (subset x y)(subset y x))) )
(SEXPR cart ( LAMBDA (x y)(PROG (u v w) a (COND ((NULL x)(RETURN (reverse w))))(SETQ u (CAR x))(SETQ x (CDR x))(SETQ v y) b (COND ((NULL v)(GO a)))(SETQ w (CONS (LIST u (CAR v)) w))(SETQ v (CDR v))(GO b))) )
(SEXPR pair ( LAMBDA (x y)(COND ((NULL x) NIL)(T (CONS (CONS (CAR x)(CAR y))(pair (CDR x)(CDR y)))))) )
(SEXPR dpair ( LAMBDA (x y)(PROG (u)(SETQ u x) a (COND ((NULL u)(RETURN x)))(RPLACA u (CONS (CAR u)(CAR y)))(SETQ u (CDR u))(SETQ y (CDR y))(GO a))) )
(SEXPR assoc ( LAMBDA (x a)(COND ((NULL a) NIL)((equal x (CAAR a))(CAR a))(T (assoc x (CDR a))))) )
(SEXPR pairlis ( LAMBDA (x y a)(COND ((NULL x) a)(T (CONS (CONS (CAR x)(CAR y))(pairlis (CDR x)(CDR y) a))))) )
(SEXPR subst ( LAMBDA (x y z)(COND ((equal y z) x)((ATOM z) z)(T (CONS (subst x y (CAR z))(subst x y (CDR z)))))) )
(SEXPR sublis ( LAMBDA (a y)(COND ((NULL y) NIL)((ATOM y)(sub2 a y))(T (CONS (sublis a (CAR y))(sublis a (CDR y)))))) )
(SEXPR sub2 ( LAMBDA (a y)(COND ((NULL a) y)((EQ y (CAAR a))(CDAR a))(T (sub2 (CDR a) y)))) )
(SEXPR sassoc ( LAMBDA (x a f)(COND ((NULL a)(f))((equal x (CAAR a))(CAR a))(T (sassoc x (CDR a) f)))) )
(SEXPR maplist ( LAMBDA (x f)(COND ((NULL x) NIL)(T (CONS (f x)(maplist (CDR x) f))))) )
(SEXPR mapcar ( LAMBDA (x f)(maplist x (FUNCTION (LAMBDA (x)(f (CAR x)))))) )
(SEXPR map ( LAMBDA (x f)(PROG NIL a (COND ((ATOM x)(RETURN x)))(f x)(SETQ x (CDR x))(GO a))) )
(SFEXPR push ( LAMBDA (*1 *2)(EVAL (LIST (QUOTE SETQ) *2 (LIST (QUOTE CONS) *1 *2)))) )
(SFEXPR pop ( LAMBDA (*1)(EVAL (LIST (QUOTE SETQ) *1 (LIST (QUOTE CDR) *1)))) )
(SFEXPR popup ( LAMBDA (*1 *2)(PROG NIL (EVAL (LIST (QUOTE SETQ) *1 (LIST (QUOTE CAR) *2)))(EVAL (LIST (QUOTE SETQ) *2 (LIST (QUOTE CDR) *2))))) )
(SEXPR putprop ( LAMBDA (a i p)(PROG (u v)(SETQ u (CONS NIL (PROPLIST a)))(SETQ v u) a (COND ((NULL (CDR v))(RPLACD v (LIST i p)))((EQ (CAR (SETQ v (CDR v))) i)(COND ((NULL (CDR v))(RPLACD v (LIST p)))(T (RPLACA (CDR v) p))))(T (GO a)))(SPROPL a (CDR u))(RETURN a))) )
(SFEXPR define ( LAMBDA (x)(COND ((NULL x) NIL)(T (CONS (EVAL (LIST (QUOTE SEXPR)(CAAR x)(CADAR x)))(EVAL (LIST (QUOTE define)(CDR x))))))) )
(SFEXPR deflist ( LAMBDA (x i)(COND ((NULL x) NIL)(T (CONS (putprop (CAAR x) i (CADAR x))(EVAL (LIST (QUOTE deflist)(CDR x) i)))))) )
(SEXPR select ( LAMBDA (e L e0)(COND ((NULL L) e0)((EQ e (CAR L))(CADR L))(T (select e (CDDR L) e0)))) )
(SEXPR prop ( LAMBDA (a i f)(PROG (u)(SETQ u (PROPLIST a)) a (COND ((NULL u)(RETURN f)))((EQ (CAR u) i)(RETURN (CDR u))))(SETQ u (CDR u))(GO a)) )
(SMACRO cpl ( LAMBDA (x)(COND ((NULL x) NIL)(T (LIST (QUOTE CONS)(LIST (QUOTE QUOTE)(CAR x))(LIST (QUOTE cpl)(CDR x)))))) )
