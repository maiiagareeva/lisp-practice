;начало списка
(DEFUN MY_BEGIN(L)
    (COND
      
    )
)
;(print (MY_BEGIN '(1 3 6)))

;???????????????
(DEFUN MY_MEMBER(X L)
   (COND 
     
)
)
;(print (MY_MEMBER 7 '(1 3 6)))


;длина списка
(DEFUN MY_LEN(L)
    (COND
       
	)
)
;(print (MY_LEN '(1 NIL 3 6)))


;последний элемент списка
(DEFUN MY_LAST(L)
    (COND
       
	)
)
;(print (MY_LAST '(1 NIL 3 6)))


;переворачиваем список
(DEFUN MY_REVERSE(L)
	(COND
	
)
)
;(print (MY_REVERSE '(1 NIL 3 6)))


;считаем кол-во атомов в списке
(DEFUN COUNT_ATOMS(L)
    (COND
    
)
)
;(print (COUNT_ATOMS '(1 NIL 3 6)))



;составляем новый список, состоящий только из атомов исходного
(DEFUN ONLY_ATOMS(L)
	(COND
	
)
)
;(print (ONLY_ATOMS '(1 NIL 3 6)))


;вставляем элемент в упорядоченный список
(DEFUN INTO_SORT(X L)
	(COND
	
)
)
;(print (INTO_SORT 5 '(1 3 6)))


;сортировка списка
(DEFUN MY_SORT(L)
	(COND
	
)
)
;(print (MY_SORT '(7 2 3)))


;слияние двух списков в один
(DEFUN MY_MERGE(A L)
	(COND
	
)
)
;(print (MY_MERGE '(7 2 3) '(1 4 5)))

;слияние двух упорядоченных списков в один
(DEFUN MY_MERGE_SORT_LISTS(A L)
	(COND
	
)
)
;(print (MY_MERGE '(7 2 3) '(1 4 5)))

;минимальный элемент списка
(DEFUN MIN_LIST(L)
	(COND
	
)
)
;(print (MIN_LIST '(4 5 1)))

;сумма всех элементов списка
(DEFUN SUM_LIST(L)
	(COND
	
)
)
;(print (SUM_LIST '(4 5 6)))

;удалить элемент из списка
(DEFUN ONION(X L)
	(COND
	
)
)
;(print (ONION 6 '(4 5 6)))


;сумма делителей числа
(DEFUN SUMM_DEL(N)
	(COND
	
)
)
;(print (SUMM_DEL 6))

;проверка числа на совершенство
(DEFUN IS_IDEAL(N)
	(COND
	
)
)
;(print (IS_IDEAL 6))

;получаеет список всех простых чисел на отрезке [A,B]
(DEFUN ALL_PRIMES(A B)
	(COND
	
)
)
;(print (ALL_PRIMES 1 10))


;получаеет список всех совершенных чисел на отрезке [A,B]
(DEFUN ALL_IDEALS(A B)
	(COND
	
)
)
;(print (ALL_IDEALS 1 100))


;является ли список L множеством
(DEFUN ISSET(L)
	(COND
	
)
)
;(print (ISSET '(2 3 3 4)))

;превращает список L в множество
(DEFUN INTO_SET(L)
	(COND
	
)
)
;(print (INTO_SET '(1 2 2 2 3)))


;проверяет: является ли список L подмножеством списка R
(DEFUN IS_SUBSET(L R)
	(COND
	
)
)
;(print (IS_SUBSET '(1 2 3) '(1 2 4 5 3)))

;проверка множеств на равенство
(DEFUN EQ_SET(L R)
	(COND
	
)
)
;(print (EQ_SET '(1 2 3) '(3 2 1)))


;объединие двух множеств
(DEFUN LIST_UNION(L R)
	(COND
	
)
)
;(print (LIST_UNION '(1 2 3) '(4 5 6)))

;пересечение двух множеств
(DEFUN LIST_CROSS(L R)
	(COND
	
)
)
;(print (LIST_CROSS '(1 2 4 3) '(4 5 6)))

;возвращает симметрическую разность двух множеств
(DEFUN LIST_S_DIFFERENCE(L R)
	(COND
	
)
)
;(print (LIST_CROSS '(1 2 4 5) '(4 5 6)))


;вычисление биноминального коэффицента через факториал
(DEFUN cnk(n k)
	(COND
	
)
)
;(print (cnk 5 4))

;вычисление биноминального коэффицента через комбинаторную формулу
(DEFUN cnk(L, R)
	(COND
	
)
)
;(print (cnk 5 4))


;получение итой строки треугольника Паскаля, начиная с катого элемента
(DEFUN stroka(k i)
	(COND
	
)
)
;(print (stroka 5 4))

;печать первых n строк треугольника Паскаля
(DEFUN triangle(n)
	(COND
	
)
)
;(print (triangle 4))

;возвращает первый столбец матрицы М
(DEFUN f1(M)
	(COND
	
)
)
;(print (f1 '((1 2 3)(4 5 6)(7 8 9)))

;возвращает матрицу без первого столбца
(DEFUN f2(M)
	(COND
	
)
)
;(print (f2 '((1 2 3)(4 5 6)(7 8 9)))


;возвращает транспонированную матрицу
(DEFUN f3(M)
	(COND
	
)
)
;(print (f3 '((1 2 3)(4 5 6)(7 8 9)))

;возвращает сумму двух матриц
(DEFUN f4(m1 m2)
	(COND
	
)
)
;(print (f4 '((1 2 3)(4 5 6)) '((1 1 1)(1 1 1)))


;возвращает единичную матрицу размерности N на N
(DEFUN f5(n)
	(COND
	
)
)
;(print (f5 n))

;возвращает нижнюю треугольную матрицу размерности N на N
(DEFUN f6(n)
	(COND
	
)
)
;(print (f6 n))
